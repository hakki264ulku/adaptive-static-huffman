[{"C:\\Users\\hakki\\huffman-coding\\src\\index.js":"1","C:\\Users\\hakki\\huffman-coding\\src\\App.js":"2","C:\\Users\\hakki\\huffman-coding\\src\\NavBar.js":"3","C:\\Users\\hakki\\huffman-coding\\src\\StaticHuffman.js":"4","C:\\Users\\hakki\\huffman-coding\\src\\AdaptiveHuffman.js":"5","C:\\Users\\hakki\\huffman-coding\\src\\huffmanCoding.js":"6","C:\\Users\\hakki\\huffman-coding\\src\\adaptiveHuffmanCoding.js":"7","C:\\Users\\hakki\\huffman-coding\\src\\TopContainer.js":"8"},{"size":219,"mtime":1607796838769,"results":"9","hashOfConfig":"10"},{"size":784,"mtime":1609162254679,"results":"11","hashOfConfig":"10"},{"size":1380,"mtime":1609759054016,"results":"12","hashOfConfig":"10"},{"size":5242,"mtime":1609163671669,"results":"13","hashOfConfig":"10"},{"size":2766,"mtime":1609165032600,"results":"14","hashOfConfig":"10"},{"size":3415,"mtime":1609757286518,"results":"15","hashOfConfig":"10"},{"size":10442,"mtime":1609756787992,"results":"16","hashOfConfig":"10"},{"size":3021,"mtime":1609759131469,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"uz90y9",{"filePath":"21","messages":"22","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"20"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"26","messages":"27","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"20"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"20"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"20"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"20"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\hakki\\huffman-coding\\src\\index.js",[],["40","41"],"C:\\Users\\hakki\\huffman-coding\\src\\App.js",["42","43","44","45","46"],"import './App.css';\nimport { useEffect, useState } from \"react\"\nimport Tree from 'react-d3-tree';\nimport tw from \"twin.macro\"\nimport React from \"react\";\nimport NavBar from './NavBar'\nimport TopContainer from './TopContainer'\nimport StaticHuffman from \"./StaticHuffman\"\nimport AdaptiveHuffman from \"./AdaptiveHuffman\"\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link\n} from \"react-router-dom\";\n\nfunction App() {\n  return (\n    <Router>\n      <TopContainer />\n      <NavBar />\n      <Switch>\n        <Route exact path=\"/staticHuffman\">\n          <StaticHuffman />\n        </Route>\n        <Route exact path=\"/adaptiveHuffman\">\n          <AdaptiveHuffman />\n        </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nconst Button = tw.button`no-underline`\n\n\nexport default App;\n","C:\\Users\\hakki\\huffman-coding\\src\\NavBar.js",["47","48"],"C:\\Users\\hakki\\huffman-coding\\src\\StaticHuffman.js",["49"],"import './App.css';\r\nimport { useEffect, useState } from \"react\"\r\nimport Tree from 'react-d3-tree';\r\nimport tw from \"twin.macro\"\r\nimport { produceTree, decodeText } from \"./huffmanCoding\"\r\n\r\n\r\nfunction StaticHuffman() {\r\n    const [input, SetInput] = useState(\"\")\r\n    const [treeData, setTreeData] = useState([{ name: \"empty root\" }])\r\n    const [info, setInfo] = useState([])\r\n    const [usedOnce, setUsedOnce] = useState(false)\r\n    const [encoded, setEncoded] = useState(\"\")\r\n    const [decoded, setDecoded] = useState(\"\")\r\n    const [root, setRoot] = useState({})\r\n    const [ratio, setRatio] = useState(0)\r\n\r\n    useEffect(() => {\r\n        if (input.length === 0 && usedOnce) {\r\n            window.location.reload()\r\n        }\r\n    }, [input])\r\n\r\n    function produce() {\r\n        let [root, arr, encodedText] = produceTree(input)\r\n        setTreeData([].concat(root))\r\n        setInfo(arr)\r\n        console.log(arr)\r\n        let val = 0\r\n\r\n        arr.forEach(i => {\r\n            val += i.freq * i.size\r\n        })\r\n\r\n        setRatio((val / (input.length*8))*100)\r\n\r\n        setRoot(root)\r\n        setUsedOnce(true)\r\n        setEncoded(encodedText)\r\n    }\r\n\r\n    function decode() {\r\n        let str = decodeText(root, encoded)\r\n        setDecoded(str)\r\n    }\r\n\r\n    let toggle = false\r\n\r\n    return (\r\n        <MainContainer>\r\n            <Container>\r\n                <Input value={input} onChange={(e) => SetInput(e.target.value)} />\r\n                <Buttons>\r\n                    <Button onClick={() => produce()}>produce tree</Button>\r\n                    <Button2 onClick={() => decode()}>Decode Text</Button2>\r\n                    <Ratio>Compresion Ratio (%) ={ratio}</Ratio>\r\n                </Buttons>\r\n                <InfoContainer>\r\n                    <InfoTable>\r\n                        <InfoRow>\r\n                            <InfoHeader>Char</InfoHeader>\r\n                            <InfoHeader>Frequency</InfoHeader>\r\n                            <InfoHeader>Bit Code</InfoHeader>\r\n                            <InfoHeader>Size(bits)</InfoHeader>\r\n                        </InfoRow>\r\n\r\n                        {info.map((i) => {\r\n                            if (!toggle) {\r\n                                toggle = true\r\n                                return (\r\n                                    <InfoRow1 key={i.bitCode}>\r\n                                        <InfoData>{i.name}</InfoData>\r\n                                        <InfoData>{i.freq}</InfoData>\r\n                                        <InfoData>{i.bitCode}</InfoData>\r\n                                        <InfoData>{i.size}</InfoData>\r\n                                    </InfoRow1>\r\n                                )\r\n                            } else {\r\n                                toggle = false\r\n                                return (\r\n                                    <InfoRow2 key={i.bitCode}>\r\n                                        <InfoData>{i.name}</InfoData>\r\n                                        <InfoData>{i.freq}</InfoData>\r\n                                        <InfoData>{i.bitCode}</InfoData>\r\n                                        <InfoData>{i.size}</InfoData>\r\n                                    </InfoRow2>\r\n                                )\r\n                            }\r\n                        }\r\n                        )}\r\n                    </InfoTable>\r\n\r\n                </InfoContainer>\r\n            </Container>\r\n\r\n            <TextContainer>\r\n                <EncodedText>Encoded text: <Text>{encoded}</Text></EncodedText>\r\n                <EncodedText>Decoded text: <Text>{decoded}</Text></EncodedText>\r\n                \r\n            </TextContainer>\r\n\r\n            <TreeContainer>\r\n                <Tree\r\n                    data={treeData}\r\n                    height={400}\r\n                    width={400}\r\n                    orientation=\"vertical\"\r\n                    translate={{ x: 950, y: 140 }} />\r\n            </TreeContainer>\r\n\r\n\r\n\r\n        </MainContainer>\r\n    );\r\n}\r\n\r\n\r\nconst MainContainer = tw.div`h-screen w-screen bg-blue-100 font-sans`\r\n\r\nconst Container = tw.div`flex items-start justify-around`\r\nconst Button = tw.button`px-4 py-3 border-none hover:cursor-pointer focus:outline-none\r\nrounded-xl bg-green-500 hover:bg-green-600 text-white font-bold`\r\n\r\nconst Button2 = tw.button`px-4 py-3 border-none hover:cursor-pointer focus:outline-none\r\nrounded-xl bg-green-400 hover:bg-green-500 text-white font-bold mt-8`\r\n\r\nconst Buttons = tw.div`flex flex-col items-start`\r\nconst Ratio = tw.div`font-bold mt-4`\r\n\r\n\r\nconst InfoContainer = tw.div`flex flex-col rounded overflow-auto max-h-64 h-64`\r\nconst InfoTable = tw.table`table-auto bg-gray-100 text-center`\r\nconst InfoRow = tw.tr``\r\nconst InfoRow1 = tw.tr`bg-gray-300`\r\nconst InfoRow2 = tw.tr``\r\nconst InfoHeader = tw.th`bg-gray-200 font-bold px-4 py-2`\r\nconst InfoData = tw.td``\r\n\r\nconst Input = tw.textarea`overflow-auto w-1/4 h-64 max-w-lg`\r\n\r\nconst TreeContainer = tw.div`bg-green-200 mt-4 h-full w-screen`\r\n\r\nconst TextContainer = tw.div`w-screen `\r\nconst EncodedText = tw.div`ml-4 pt-8 font-bold p-2 w-4/5 max-h-36 `\r\nconst Text = tw.div`text-gray-900 font-light overflow-auto`\r\n\r\n\r\n\r\nexport default StaticHuffman;","C:\\Users\\hakki\\huffman-coding\\src\\AdaptiveHuffman.js",["50"],"import './App.css';\r\nimport { useEffect, useState } from \"react\"\r\nimport Tree from 'react-d3-tree';\r\nimport tw from \"twin.macro\"\r\nimport { produceTree, produceTreeVisualization, decode } from './adaptiveHuffmanCoding';\r\n\r\n\r\nfunction AdaptiveHuffman() {\r\n\r\n  const [treeData, setTreeData] = useState([{ name: \"empty root\" }])\r\n  const [input, setInput] = useState(\"\")\r\n  const [encoded, setEncoded] = useState(\"\")\r\n  const [decoded, setDecoded] = useState(\"\")\r\n  const [ratio, setRatio] = useState(\"\")\r\n\r\n  let produce = () => {\r\n    let [root, enc] = produceTree(input)\r\n    let tdata = produceTreeVisualization([], root)\r\n    setEncoded(enc)\r\n\r\n    let val = enc.length *1 // 1 and 0 are one bits\r\n    setRatio((val/(input.length*8))*100) // one char is 8 bits\r\n\r\n    setTreeData(tdata)\r\n  }\r\n\r\n  let decodeText = () => {\r\n    let dcd = decode(encoded)\r\n    setDecoded(dcd)\r\n    console.log(dcd)\r\n  }\r\n\r\n  return (\r\n    <MainContainer>\r\n      <Container>\r\n        <Input value={input} onChange={(e) => {\r\n          setInput(e.target.value)\r\n        }} />\r\n        <Buttons>\r\n          <Button onClick={() => produce()}>Produce Tree</Button>\r\n          <Button2 onClick={() => decodeText()}>Decode Text</Button2>\r\n          <Ratio>Compresion Ratio (%) ={ratio}</Ratio>\r\n        </Buttons>\r\n        <InfoContainer>\r\n          \r\n        </InfoContainer>\r\n      </Container>\r\n\r\n      <TextContainer>\r\n        <EncodedText>Encoded text: <Text>{encoded}</Text></EncodedText>\r\n        <EncodedText>Decoded text: <Text>{decoded}</Text></EncodedText>\r\n      </TextContainer>\r\n\r\n\r\n      <TreeContainer>\r\n        <Tree data={treeData}\r\n          height={400}\r\n          width={400}\r\n          orientation=\"vertical\"\r\n          translate={{ x: 950, y: 140 }} />\r\n\r\n\r\n      </TreeContainer>\r\n\r\n\r\n    </MainContainer>\r\n  );\r\n}\r\n\r\nconst MainContainer = tw.div`h-screen w-screen bg-blue-100 font-sans`\r\nconst Container = tw.div`flex items-start justify-around`\r\n\r\nconst Buttons = tw.div`flex flex-col items-start`\r\nconst Ratio = tw.div`font-bold mt-4`\r\n\r\nconst Button = tw.button`px-4 py-3 border-none hover:cursor-pointer focus:outline-none\r\nrounded-xl bg-green-500 hover:bg-green-600 text-white font-bold`\r\n\r\nconst Button2 = tw.button`px-4 py-3 border-none hover:cursor-pointer focus:outline-none\r\nrounded-xl bg-green-400 hover:bg-green-500 text-white font-bold mt-8`\r\n\r\nconst InfoContainer = tw.div`flex flex-col rounded overflow-auto max-h-64 h-64`\r\nconst Input = tw.textarea`overflow-auto w-1/4 h-64 max-w-lg`\r\n\r\nconst TreeContainer = tw.div`bg-green-200 mt-4 h-full w-screen`\r\n\r\nconst TextContainer = tw.div`w-screen `\r\nconst EncodedText = tw.div`ml-4 pt-8 font-bold p-2 w-4/5`\r\nconst Text = tw.div`text-gray-900 font-light overflow-auto`\r\n\r\nexport default AdaptiveHuffman;\r\n","C:\\Users\\hakki\\huffman-coding\\src\\huffmanCoding.js",["51"],"import PriorityQueue from \"js-priority-queue\"\r\n\r\nclass HuffmanNode {\r\n    constructor(data, c, left, right) {\r\n        this.data = data\r\n        this.c = c\r\n        this.children = [left, right]\r\n        this.left = left\r\n        this.right = right\r\n    }\r\n}\r\n\r\nclass TreeNode {\r\n    constructor(name, data, left, right) {\r\n        this.name = name\r\n        this.attributes = { data }\r\n        if (Object.keys(left).length === 0 && Object.keys(right).length !== 0) {\r\n            this.children = [right]\r\n        } else if (Object.keys(right).length === 0 && Object.keys(left).length !== 0) {\r\n            this.children = [left]\r\n        } else if (Object.keys(right).length !== 0 && Object.keys(left).length !== 0) {\r\n            this.children = [left, right]\r\n        }\r\n    }\r\n}\r\n\r\n// recursive print function to print the chars and their frequencies\r\nlet arr=[]\r\nlet encodedLetters = {}\r\nfunction printCode(root, s) {\r\n\r\n    if (!root.children) {\r\n        arr = arr.concat({name:root.name, freq:root.attributes.data, bitCode:s, size: s.length})\r\n        encodedLetters[root.name] = s\r\n        return\r\n    }\r\n\r\n    // for going left: add 0 to the code\r\n    // for going right: add 1 to the code\r\n    printCode(root.children[0], s + \"0\")\r\n    printCode(root.children[1], s + \"1\")\r\n}\r\n\r\nlet encodedText=\"\"\r\nfunction encodeTheCode(InputStr) {\r\n    for (const c of InputStr) {\r\n        encodedText = `${encodedText}${encodedLetters[c]}`\r\n    }\r\n}\r\n\r\nfunction decodeText(root, EncodedText) {\r\n    let decoded = \"\"\r\n\r\n    let curr = root\r\n    for (let i = 0; i < EncodedText.length; i++) {\r\n        if(EncodedText[i] === \"0\") curr = curr.children[0]\r\n        else curr = curr.children[1]\r\n\r\n        if(!Object.keys(curr).includes(\"children\")){\r\n            decoded += curr.name\r\n            curr = root\r\n        }\r\n    }\r\n    return decoded\r\n}\r\n\r\n// Returns a map(key:value) -> char:occurence\r\nfunction getCountsOfChars(input) {\r\n    let counts = {};\r\n\r\n    let ch, i, len, count;\r\n\r\n    // Loop through the string...\r\n    for (i = 0, len = input.length; i < len; ++i) {\r\n        ch = input.charAt(i);\r\n\r\n        count = counts[ch];\r\n\r\n        counts[ch] = count ? count + 1 : 1;\r\n    }\r\n\r\n    return counts\r\n\r\n}\r\n\r\nfunction getCharArrayAndCharFrequency(input) {\r\n    let mapCounts = getCountsOfChars(input)\r\n\r\n    let chars = Object.keys(mapCounts)\r\n    let frequencies = Object.values(mapCounts)\r\n\r\n    return [chars, frequencies]\r\n}\r\n\r\nconst compareNodes = function (n1, n2) {\r\n    return n1.attributes.data - n2.attributes.data\r\n}\r\n\r\nfunction produceTree(str) {\r\n\r\n    let [charArray, charFreq] = getCharArrayAndCharFrequency(str)\r\n\r\n    let queue = new PriorityQueue({ comparator: compareNodes })\r\n    \r\n    for (let i = 0; i < charArray.length; i++) {\r\n        let tn = new TreeNode(charArray[i], charFreq[i], {}, {})\r\n        queue.queue(tn)\r\n    }\r\n\r\n    let root = null\r\n\r\n    while (queue.length > 1) {\r\n        let min1 = queue.dequeue()\r\n        let min2 = queue.dequeue()\r\n\r\n        let newNode = new TreeNode('-', min1.attributes.data + min2.attributes.data, min1, min2)\r\n\r\n        root = newNode\r\n\r\n        queue.queue(newNode)\r\n    }\r\n\r\n    printCode(root, \"\") //encodes by using the tree's\r\n    encodeTheCode(str) // produces the encoded text by using the encoded letters\r\n    decodeText(root, encodedText)\r\n    \r\n    return [root, arr, encodedText]\r\n}\r\n\r\nexport {\r\n    produceTree,\r\n    decodeText\r\n}","C:\\Users\\hakki\\huffman-coding\\src\\adaptiveHuffmanCoding.js",["52","53"],"// If isNyt=false & char=\"\" and have left and right children then it's an internal node\r\nclass HuffmanNode {\r\n    constructor(weight = 0, char = \"\", isNYT = false, parent = {}) {\r\n        this.weight = weight\r\n        this.parent = parent\r\n        this.left = this.right = {}\r\n        this.char = char\r\n        this.isNYT = isNYT\r\n    }\r\n}\r\n\r\n// this will return the current NYT\r\nfunction findNYT(root, str) {\r\n    if (!root) return [null, str]\r\n    if (Object.keys(root).length === 0) return [null, str]\r\n    if (root.isNYT) {\r\n        return [root, str]\r\n    } else {\r\n        if (!findNYT(root.left, str)[0]) return findNYT(root.right, str + \"1\")\r\n        else if (!findNYT(root.right, str)[0]) return findNYT(root.left, str + \"0\")\r\n    }\r\n    return [null, str]\r\n}\r\n\r\nfunction convertANumtoBinaryRepresantation(num, e) { // e -> the return represantation will be in e bits\r\n    let p = 0;\r\n    let result = \"\"\r\n    let count = 1\r\n    while (true) {\r\n        if (e - count === -1) {\r\n            break\r\n        }\r\n        if (Math.pow(2, e - count) <= num) {\r\n            result += \"1\"\r\n            num -= Math.pow(2, e - count)\r\n            count++\r\n        } else {\r\n            result += \"0\"\r\n            count++\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction findAllLeafs(root, leafArr = []) {\r\n    if (Object.keys(root.left).length === 0 && Object.keys(root.right).length === 0) {\r\n        leafArr.push(root)\r\n        return [root, leafArr]\r\n    } else if (!root) return\r\n\r\n    findAllLeafs(root.left, leafArr)\r\n    findAllLeafs(root.right, leafArr)\r\n\r\n    return leafArr\r\n}\r\n\r\nfunction updateTreeWeights2(root, treeArray) {\r\n    let allLeafs = findAllLeafs(root, [])\r\n\r\n    for (const leaff of allLeafs) {\r\n        let leaf = leaff\r\n\r\n        while (Object.keys(leaf.parent).length !== 0) {\r\n            leaf.parent.weight = leaf.parent.right.weight + leaf.parent.left.weight\r\n            checkForConflictingAndSwap(treeArray)\r\n\r\n            if (leaf.parent.left > leaf.parent.right) {\r\n                let temp = leaf.parent.left\r\n                leaf.parent.left = leaf.parent.right\r\n                leaf.parent.right = temp\r\n            }\r\n            leaf = leaf.parent\r\n        }\r\n    }\r\n}\r\n\r\nfunction findTheEncounteredNodeAndIncrementWeight(c, root, flag, strCode) {\r\n    if (Object.keys(root).length === 0 || root.isNYT) return [null, strCode]\r\n\r\n    if (root && root.char !== \"\" && root.char === c) {\r\n        if (!flag.bol) {\r\n            root.weight++\r\n            flag.bol = true\r\n            return [root, strCode]\r\n        }\r\n\r\n        return [root, strCode]\r\n    } else {\r\n        if (!findTheEncounteredNodeAndIncrementWeight(c, root.left, flag, strCode)[0]) return findTheEncounteredNodeAndIncrementWeight(c, root.right, flag, strCode + \"1\")\r\n        else if (!findTheEncounteredNodeAndIncrementWeight(c, root.right, flag, strCode)[0]) return findTheEncounteredNodeAndIncrementWeight(c, root.left, flag, strCode + \"0\")\r\n    }\r\n    return [null, strCode]\r\n}\r\n\r\n// will return the level of the node by calculating its length up to the root\r\nfunction calculateLevelOfANode(node) {\r\n    let count = 0;\r\n    if (Object.keys(node.parent).length === 0) {\r\n        return 0\r\n    }\r\n\r\n    while (Object.keys(node.parent).length !== 0) {\r\n        count++\r\n        node = node.parent\r\n    }\r\n    return count\r\n}\r\n\r\nfunction checkForConflictingAndSwap(arr) {\r\n    // zeroth indexed item is the root so no need to swap or check\r\n    for (let i = 1; i < arr.length; i++) {\r\n        for (let j = i+1; j < arr.length; j++) {\r\n            // swap condition\r\n            if (arr[i].weight < arr[j].weight) { \r\n                let bol = swapTwoNodes(arr[i], arr[j])\r\n                if (bol) {\r\n                    let temp = arr[i]\r\n                    arr[i] = arr[j]\r\n                    arr[j] = temp\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\n// their parent and parent's corresponding child nodes will be swapped\r\nfunction swapTwoNodes(a, b) {\r\n    let parentA = a.parent\r\n    let parentB = b.parent\r\n\r\n    if(Object.is(a.parent, b.parent)){\r\n        let temp = a.parent.left\r\n        a.parent.left = a.parent.right\r\n        a.parent.right = temp\r\n        return true\r\n    }\r\n\r\n    if(Object.is(a.parent, b) || Object.is(b.parent, a)) return false\r\n\r\n    if(Object.is(a, a.parent.left)) a.parent.left = b\r\n    else a.parent.right  = b\r\n\r\n    if(Object.is(b, b.parent.left)) b.parent.left = a\r\n    else b.parent.right = a\r\n\r\n    b.parent = parentA\r\n    a.parent = parentB\r\n\r\n    return true\r\n}\r\n\r\nfunction encodeFixedCode(c, e, r) {\r\n    // let k = letters[c]\r\n    let k = c.charCodeAt(0)\r\n    if (k >= 0 && k <= 2 * r) {\r\n        return convertANumtoBinaryRepresantation(k - 1, e + 1)\r\n    } else {\r\n        return convertANumtoBinaryRepresantation(k - r - 1, e)\r\n    }\r\n}\r\n\r\n// This will return the tree's root\r\nfunction produceTree(InputStr) {\r\n    let root = new HuffmanNode(0, \"\", true, {}) // initialize tree with NYT\r\n    let encounteredChars = []\r\n    let treeArray = [root] // will contain the nodes\r\n    let encodedText = \"\"\r\n    let e = 6, r = 63 // these depends on the number of chars in the alphabet\r\n\r\n    for (let c of InputStr) {\r\n        if (root.isNYT) { // means no input has added to the tree\r\n            encodedText += findNYT(root, \"\")[1]\r\n\r\n            root.left = new HuffmanNode(0, \"\", true, root) // this is a new NYT\r\n            root.right = new HuffmanNode(1, c, false, root)\r\n            root.isNYT = false\r\n\r\n            encodedText += encodeFixedCode(c, e, r)\r\n\r\n            root.weight = 1\r\n\r\n            encounteredChars = encounteredChars.concat(c)\r\n            treeArray.push(root.right)\r\n            treeArray.push(root.left)\r\n            continue\r\n        } else {\r\n\r\n            if (encounteredChars.includes(c)) {\r\n                let strCode = findTheEncounteredNodeAndIncrementWeight(c, root, { bol: false }, \"\")[1]\r\n                encodedText += strCode\r\n\r\n                checkForConflictingAndSwap(treeArray)\r\n\r\n                updateTreeWeights2(root, treeArray)\r\n                continue\r\n            } else {\r\n                let nyt = findNYT(root, \"\")[0]\r\n                encodedText += findNYT(root, \"\")[1]\r\n                encodedText += encodeFixedCode(c, e, r)\r\n\r\n                nyt.left = new HuffmanNode(0, \"\", true, nyt) // this is new NYT\r\n                nyt.right = new HuffmanNode(1, c, false, nyt)\r\n                nyt.isNYT = false\r\n\r\n                nyt.char = \"\"\r\n                nyt.weight = 1\r\n                encounteredChars = encounteredChars.concat(c)\r\n                treeArray.push(nyt.right)\r\n                treeArray.push(nyt.left)\r\n\r\n                updateTreeWeights2(root, treeArray)\r\n                checkForConflictingAndSwap(treeArray)\r\n                continue\r\n            }\r\n        }\r\n    }\r\n    return [root, encodedText]\r\n}\r\n\r\nfunction convertBinaryToDecimal(binary) {\r\n    return parseInt(binary, 2)\r\n}\r\n\r\nfunction decode(encodedText) {\r\n    let slice = \"\"\r\n    let result = \"\"\r\n    let e = 6, r = 63\r\n    let root = produceTree(result)[0]\r\n\r\n    for (let i = 0; i < e; i++) {\r\n        slice += encodedText[i]\r\n    }\r\n    encodedText = encodedText.slice(e)\r\n\r\n    if (convertBinaryToDecimal(slice) < r) {\r\n        slice += encodedText[0]\r\n        encodedText = encodedText.slice(1)\r\n        let decodedNum = convertBinaryToDecimal(slice) + 1\r\n        result += String.fromCharCode(decodedNum)\r\n        // result += getKeyByValue(letters, decodedNum)\r\n    }\r\n    root = produceTree(result)[0]\r\n\r\n    let checker = root\r\n    let read = \"\"\r\n\r\n    while (true) {\r\n        if (encodedText.length === 0) break\r\n\r\n        read += encodedText[0]\r\n\r\n        if (encodedText[0] === \"0\") checker = checker.left\r\n        else checker = checker.right\r\n\r\n        encodedText = encodedText.slice(1)\r\n        if (checker.isNYT) {\r\n            read = \"\"\r\n            for (let i = 0; i < e; i++) {\r\n                read += encodedText[i]\r\n            }\r\n            encodedText = encodedText.slice(e)\r\n\r\n            if (convertBinaryToDecimal(read) < r) {\r\n                read += encodedText[0] // read one more bit\r\n                encodedText = encodedText.slice(1)\r\n                //result += getKeyByValue(letters, convertBinaryToDecimal(read) + 1)\r\n                result += String.fromCharCode(convertBinaryToDecimal(read) + 1)\r\n                root = produceTree(result)[0]\r\n                checker = root\r\n                read = \"\"\r\n\r\n                continue\r\n            } else { //convert e bits to decimal value of e bits + r + 1\r\n                result += String.fromCharCode(convertBinaryToDecimal(read) + r + 1)\r\n\r\n                root = produceTree(result)[0]\r\n                checker = root\r\n                read = \"\"\r\n                continue\r\n            }\r\n\r\n        } else if (checker.char === \"\") {// If it's internal node\r\n            continue\r\n        } else {\r\n            result += checker.char\r\n            root = produceTree(result)[0]\r\n            checker = root\r\n            read = \"\"\r\n            continue\r\n        }\r\n    }\r\n\r\n    return result\r\n}\r\n\r\nclass TreeNode {\r\n    constructor(name, data, left, right, isNYT = false) {\r\n        this.name = name\r\n        this.attributes = { data }\r\n        if (isNYT) {\r\n            this.name = \"NYT\"\r\n            this.nodeSvgShape = {\r\n                shape: \"rect\", shapeProps: {\r\n                    width: 20,\r\n                    height: 20,\r\n                    x: -10,\r\n                    y: -10,\r\n                },\r\n            }\r\n        }\r\n        if (Object.keys(left).length === 0 && Object.keys(right).length !== 0) {\r\n            this.children = [right]\r\n        } else if (Object.keys(right).length === 0 && Object.keys(left).length !== 0) {\r\n            this.children = [left]\r\n        } else if (Object.keys(right).length !== 0 && Object.keys(left).length !== 0) {\r\n            this.children = [left, right]\r\n        }\r\n    }\r\n}\r\n\r\nfunction recursiveCall(TreeRoot) {\r\n    if (Object.keys(TreeRoot).length === 0) {\r\n        return {}\r\n    }\r\n    let bol = false\r\n    if (TreeRoot.isNYT) bol = true\r\n\r\n    return new TreeNode(TreeRoot.char, TreeRoot.weight, recursiveCall(TreeRoot.left), recursiveCall(TreeRoot.right), bol)\r\n}\r\n\r\nfunction produceTreeVisualization(treeData = [], root) {\r\n    treeData.push(recursiveCall(root))\r\n    return treeData\r\n}\r\n\r\nexport {\r\n    produceTree,\r\n    produceTreeVisualization,\r\n    decode\r\n}","C:\\Users\\hakki\\huffman-coding\\src\\TopContainer.js",[],{"ruleId":"54","replacedBy":"55"},{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","severity":1,"message":"59","line":2,"column":10,"nodeType":"60","messageId":"61","endLine":2,"endColumn":19},{"ruleId":"58","severity":1,"message":"62","line":2,"column":21,"nodeType":"60","messageId":"61","endLine":2,"endColumn":29},{"ruleId":"58","severity":1,"message":"63","line":3,"column":8,"nodeType":"60","messageId":"61","endLine":3,"endColumn":12},{"ruleId":"58","severity":1,"message":"64","line":14,"column":3,"nodeType":"60","messageId":"61","endLine":14,"endColumn":7},{"ruleId":"58","severity":1,"message":"65","line":34,"column":7,"nodeType":"60","messageId":"61","endLine":34,"endColumn":13},{"ruleId":"58","severity":1,"message":"59","line":2,"column":10,"nodeType":"60","messageId":"61","endLine":2,"endColumn":19},{"ruleId":"58","severity":1,"message":"66","line":5,"column":8,"nodeType":"60","messageId":"61","endLine":5,"endColumn":21},{"ruleId":"67","severity":1,"message":"68","line":22,"column":8,"nodeType":"69","endLine":22,"endColumn":15,"suggestions":"70"},{"ruleId":"58","severity":1,"message":"59","line":2,"column":10,"nodeType":"60","messageId":"61","endLine":2,"endColumn":19},{"ruleId":"58","severity":1,"message":"71","line":3,"column":7,"nodeType":"60","messageId":"61","endLine":3,"endColumn":18},{"ruleId":"58","severity":1,"message":"72","line":26,"column":9,"nodeType":"60","messageId":"61","endLine":26,"endColumn":10},{"ruleId":"58","severity":1,"message":"73","line":96,"column":10,"nodeType":"60","messageId":"61","endLine":96,"endColumn":31},"no-native-reassign",["74"],"no-negated-in-lhs",["75"],"no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'useState' is defined but never used.","'Tree' is defined but never used.","'Link' is defined but never used.","'Button' is assigned a value but never used.","'StaticHuffman' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'usedOnce'. Either include it or remove the dependency array.","ArrayExpression",["76"],"'HuffmanNode' is defined but never used.","'p' is assigned a value but never used.","'calculateLevelOfANode' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"77","fix":"78"},"Update the dependencies array to be: [input, usedOnce]",{"range":"79","text":"80"},[741,748],"[input, usedOnce]"]